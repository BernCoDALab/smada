[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Course overview",
    "section": "",
    "text": "Statistics has become an indispensable tool in prehistoric archaeology. This course is intended on the one hand to give the participants the skills to understand and reproduce statistical analyses in literature and on the other hand to enable them to use such analyses for their scientific work themselves.\nBasic statistical concepts will be explained and simple uni- and bivariate methods of descriptive, explorative and inductive statistics will be presented. An important part is the practical application of these methods. This is to be carried out with the help of the statistics software R, a open source and free-of-charge, yet extremely powerful computing environment.\nThe course is suitable for students of all semesters; no statistical knowledge or expertise in special computer programs is required. It consists of lectures, practical exercises, and tutorials. Assessment will be based on practical assignments and a final exam (theoretical and/or practical).\nThe course will be taught in English.\n\nKey dates\nWill be made available soon.\n\n\nLearning objectives\nStudents are familiar with basic statistical procedures and can apply them to archaeological case studies. Furthermore, they are familiar with the basic usage of the statistics programme R.\n\n\nInstructors\n\n\n\n\n\nMartin Hinz\nSenior Researcher (Oberassistent), IAW Bern\nmartin.hinz@unibe.ch\n\n\n\n\nMeeting times & locations\n\nLectures\nTuesday from 12:15-14:00, Seminarraum 016, Mittelstrasse 43, 3012 Bern\nThe course will be held in presence. The teaching content is additionally provided by means of videos and other material. Students are encouraged to work on this independently and to deepen it if necessary. I will respond as quickly as possible to questions sent to me via email.\nYour own computer equipment is recommended. If you have any problems in this regard, please let me know in advance. We will work exclusively with free software, if possible with open source solutions.\n\n\nOffice hours\nto be announced\n\n\n\nPre-requisites\nNone except motivation and the desire to learn, as well as the readiness to work independently.\n\nThis site was last updated at 10:44 on 03 Feb 2025"
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "date\ntitle\ntopics\nhomework\nhomework_date\n\n\n\n\n18.02.25\nIntroduction\nBasic terms, Literature, Data, Levels of Measurement, Data Collection\nNA\nNA\n\n\n25.02.25\nIntroduction into R\nR programming, Data types & structures, Basic calculations, Data import/export, Variables & operations\nNA\nNA\n\n\n04.03.25\nExplorative Statistics/Graph. Display\nPlots, Plots, Plots\nNA\nNA\n\n\n11.03.25\nDescriptive Statistics\nData Distribution, Central Tendency, Dispersion Measures, Shape of Distributions\nNA\nNA\n\n\n18.03.25\nNonparametric Tests\nInductive Statistics, Hypothesis Testing, Nonparametric Tests, Chi-Square Test, Kolmogorov-Smirnov Test\nNA\nNA\n\n\n25.03.25\n*no class*\n\nNA\nNA\n\n\n01.04.25\nBasic Probability Theory\nProbability Theory, Statistical Tests, Sampling & Population, Combinatorics, Binomial Distribution\nNA\nNA\n\n\n08.04.25\nParametric Tests\nData Sampling, Parametric vs. Non-Parametric Tests, Normality Testing, t-Test & F-Test, ANOVA\nNA\nNA\n\n\n15.04.25\nRegression & Correlation\nRegression Analysis, Correlation, Data Visualization, Statistical Modelling\nNA\nNA\n\n\n22.04.25\n*no class*\n\nNA\nNA\n\n\n29.04.25\nCluster Analysis\nDistance Measures, Hierarchical Clustering, Non-Hierarchical Clustering\nNA\nNA\n\n\n06.05.25\n*no class*\n\nNA\nNA\n\n\n13.05.25\nCorrespondence Analysis\nCorrespondence Analysis, Multidimensional Data & Data Representation, Data Normalisation\nNA\nNA\n\n\n20.05.25\n*no class*\n\nNA\nNA\n\n\n27.05.25\nTest\nblood, toil, tears, sweat\nNA\nNA"
  },
  {
    "objectID": "comp_labs.html",
    "href": "comp_labs.html",
    "title": "Computer Labs",
    "section": "",
    "text": "date\ntitle\nlab_video\n\n\n\n\n18.02.25\nIntroduction\nNA\n\n\n25.02.25\nIntroduction into R\nNA\n\n\n04.03.25\nExplorative Statistics/Graph. Display\nNA\n\n\n11.03.25\nDescriptive Statistics\nNA\n\n\n18.03.25\nNonparametric Tests\nNA\n\n\n25.03.25\n*no class*\nNA\n\n\n01.04.25\nBasic Probability Theory\nNA\n\n\n08.04.25\nParametric Tests\nNA\n\n\n15.04.25\nRegression & Correlation\nNA\n\n\n22.04.25\n*no class*\nNA\n\n\n29.04.25\nCluster Analysis\nNA\n\n\n06.05.25\n*no class*\nNA\n\n\n13.05.25\nCorrespondence Analysis\nNA\n\n\n20.05.25\n*no class*\nNA\n\n\n27.05.25\nTest\nNA"
  },
  {
    "objectID": "additional_information.html",
    "href": "additional_information.html",
    "title": "Classroom conduct",
    "section": "",
    "text": "Classroom conduct\nWe are dedicated to providing a welcoming and supportive learning environment for all students, regardless of their background, identity, physical appearance, or manner of communication. Any form of language or behavior used to exclude, intimidate, or cause discomfort will not be tolerated. This applies to all course participants (instructor, students, guests). In order to foster a positive and professional learning environment, we ask the following:\n\nPlease let us know if you have a name or set of preferred pronouns that you would like us to use\nPlease let us know if anyone in class says something that makes you feel uncomfortable[1]\n\nIn addition, we encourage the following kinds of behaviors:\n\nUse welcoming and inclusive language\nShow courtesy and respect towards others\nAcknowledge different viewpoints and experiences\nGracefully accept constructive criticism\n\nAlthough we strive to create and use inclusive materials in this course, there may be overt or covert biases in the course material due to the lens with which it was written. Your suggestions about how to improve the value of diversity in this course are encouraged and appreciated.\nPlease note: The University of Bern is committed to a non-discriminatory environment. This applies in particular to discrimination on the basis of gender (sexism) and sexual assaults (sexual harassment): we are all entitled to protection of our personal integrity at work and during our studies and to the respect of our limits. The University of Bern is also legally obliged to protect its members from sexual harassment. In particular, superiors are also responsible for looking out and reacting.\nIf you believe you have been a victim of any form of discrimination, you have the right to report it to the University.\n\n\n\nAccess & accommodations\nAll students deserve access to the full range of learning experiences, and we are committed to creating inclusive and accessible learning environments consistent with federal and state laws. If you feel like your performance in class is being impacted by your experiences outside of class, please talk with us.\n\nDisabilities\nIf you have already established accommodations with Disability Resources for Students (DRS), please communicate your approved accommodations to us at your earliest convenience so we can discuss your needs in this course. If you have not yet established services through DRS, but have a temporary health condition or permanent disability that requires accommodations (e.g., mental health, learning, vision, hearing, physical impacts), you are welcome to contact DRS at 206-543-8924 or via email or their website. DRS offers resources and coordinates reasonable accommodations for students with disabilities and/or temporary health conditions. Reasonable accommodations are established through an interactive process between you, your instructor(s) and DRS.\n\n\nReligious observances\nStudents who expect to miss class or assignments as a consequence of their religious observance will be provided with a reasonable accommodation to fulfill their academic responsibilities. Absence from class for religious reasons does not relieve students from responsibility for the course work required during the period of absence. It is the responsibility of the student to provide the instructor with advance notice of the dates of religious holidays on which they will be absent. Students who are absent will be offered an opportunity to make up the work, without penalty, within a reasonable time, as long as the student has made prior arrangements.\n\n\n\nTechnology\nThis course will revolve around hands-on computing exercises that demonstrate the topics of interest. Therefore, students are strongly recommended to bring their own laptop to class, although students are certainly free to work with one another. For students without access to a personal laptop: Please let us know in time, and we will try to find a solution.\nAll of the software we will be using is free and platform independent, meaning students may use macOS, Linux, or Windows operating systems. In addition to a web browser, we will be using the free GIS software QGIS. The instructor will be available to help students troubleshoot any software installation problems.\n\n\nTeaching methodology\nThis course will introduce new material primarily through prepared slides and videos. What is learned is then applied under supervision. Students will be expected to work both individually and collaboratively during this time and also in general; course content and evaluation will emphasize the communication of ideas and the ability to think critically more so than a specific pathway or method. Other areas of this website provide an overview of the topics to be covered, including links to lecture materials, computer labs, and homework assignments.\n\n\nCommunication\nThis course will involve a lot of communication between and among students and the instructor. Short questions should be addressed to us via email; we will try my best to respond to your message within 24 hours. Under more normal circumstances, detailed questions would be addressed to us in person–either after class or during a scheduled meeting. In this case, however, we will schedule one-on-one or group video calls as needed.\n\n\nEvaluation\nThe exact terms of evaluation will be decided within the first week of the course. Here is what has been the rule for earlier courses in a similar setting:\nStudents will be evaluated on their knowledge of course content and their ability to communicate their understanding of the material via individual homework assignments (60%) and class participation (40%). There will be 12 homework assignments, each of which will count toward 5% of the final grade. Please note, all assignments must be turned in to achieve a passing grade.\n\nHomework (60%)\nThe “homework” is due by 17:59 on the following Tuesday. It will consist of some small tasks and practical approaches based on topics covered. There will be 12 assignments worth 5% each. Your learning in the class will be greatly enhanced by doing the “homework” which consist of applying the material you learn in each lecture to a data set.\n\n\nParticipation (40%)\nWe expect a certain amount of engagement from each student, which includes independently preparing the course content and attending and participating in the computer labs.\nStudents should discuss any potential schedule conflicts with the instructor during the first week of class.\n\n\n\n\nAcademic integrity\nFaculty and students at the University of Bern are expected to maintain the highest standards of academic conduct, professional honesty, and personal integrity. Plagiarism, cheating, and other academic misconduct are serious violations of the Scientific Code of Conduct. Students who have been guilty of a violation will receive zero points for the assignment in question.\n\n\nEvaluation by you\nWith the help of standardised student feedback, courses at the University of Bern are continuously reviewed and further developed. All teaching staff and all courses are regularly evaluated.\nIn due course at the end of the semester, you will be provided with a link that will allow you to evaluate the course. Please take this opportunity to help us improve our teaching and thus your learning success!\n\n\nMental health\nIf you should feel like you need some help, please consider the following resources available to students.\nIf you are experiencing a life-threatening emergency, please dial 112.\nCounseling Center Phone: 031 / 635 24 35\n\n\nEndnotes\n[1] If the instructor should be the one to say or do something that makes a student uncomfortable, the student should feel free to contact the Director of the Prehistoric Archaeology of Bern University.\n\nThis site was last updated at 16:15 on 28 Jan 2025"
  },
  {
    "objectID": "homework.html",
    "href": "homework.html",
    "title": "Homework",
    "section": "",
    "text": "Send your homework before the homework date to martin.hinz@unibe.ch.\n\n\n\nHomework\nHomework Date\nHomework Data"
  },
  {
    "objectID": "homework.html#handing-in",
    "href": "homework.html#handing-in",
    "title": "Homework",
    "section": "",
    "text": "Send your homework before the homework date to martin.hinz@unibe.ch.\n\n\n\nHomework\nHomework Date\nHomework Data"
  },
  {
    "objectID": "lectures.html",
    "href": "lectures.html",
    "title": "Lectures",
    "section": "",
    "text": "date\ntitle\ntopics\nslides\nslides_pdf\n\n\n\n\n18.02.25\nIntroduction\nBasic terms, Literature, Data, Levels of Measurement, Data Collection\n\n\n\n\n25.02.25\nIntroduction into R\nR programming, Data types & structures, Basic calculations, Data import/export, Variables & operations\n\n\n\n\n04.03.25\nExplorative Statistics/Graph. Display\nPlots, Plots, Plots\n\n\n\n\n11.03.25\nDescriptive Statistics\nData Distribution, Central Tendency, Dispersion Measures, Shape of Distributions\n\n\n\n\n18.03.25\nNonparametric Tests\nInductive Statistics, Hypothesis Testing, Nonparametric Tests, Chi-Square Test, Kolmogorov-Smirnov Test\n\n\n\n\n25.03.25\n*no class*\n\n\n\n\n\n01.04.25\nBasic Probability Theory\nProbability Theory, Statistical Tests, Sampling & Population, Combinatorics, Binomial Distribution\n\n\n\n\n08.04.25\nParametric Tests\nData Sampling, Parametric vs. Non-Parametric Tests, Normality Testing, t-Test & F-Test, ANOVA\n\n\n\n\n15.04.25\nRegression & Correlation\nRegression Analysis, Correlation, Data Visualization, Statistical Modelling\n\n\n\n\n22.04.25\n*no class*\n\n\n\n\n\n29.04.25\nCluster Analysis\nDistance Measures, Hierarchical Clustering, Non-Hierarchical Clustering\n\n\n\n\n06.05.25\n*no class*\n\n\n\n\n\n13.05.25\nCorrespondence Analysis\nCorrespondence Analysis, Multidimensional Data & Data Representation, Data Normalisation\n\n\n\n\n20.05.25\n*no class*\n\n\n\n\n\n27.05.25\nTest\nblood, toil, tears, sweat"
  },
  {
    "objectID": "02_session/02-chapter.html",
    "href": "02_session/02-chapter.html",
    "title": "Introduction into R",
    "section": "",
    "text": "When we first start R Studio, we see a screen divided into several windows. On the left-hand side, directly after the start, we are greeted by the large R window, the Console. This is where the actual R programme is located. On the right, there are windows that provide further helpful functions. In the upper area we have the window in which we can see the working environment. On the one hand, there is the actual environment, marked by the tab ‘Environment’. Next to this, perhaps of interest to us at the moment, is the ‘History’ tab, in which we can see the sequence of commands entered so far. The file manager is located in the lower right-hand corner. Other tabs contain information about diagrams (plots), packages and a window in which we can use the R help system.\nOne important window is still missing: the code or script window. This only appears when we open a new R file. To do this, either click on the plus symbol at the top left or select ‘File -&gt; New File’ from the menu. This opens another window which is placed in the top left by default and in which you enter your programme code for the analyses. This window functions as a normal text editor window, i.e. if you press Enter here, the text is not directly executed, but a new line is created. To actually execute a command, you can either click on the Run symbol in the upper area or use the keyboard shortcut Control Enter.\n\n\n\n\n\n\nAfter R is started, you end on the prompt.\n&gt;\nThis prompt expects your commands. It can be used to directly enter commands or conduct calculations like with a normal calculator. We mainly will not use R in this way.Most of the real work is done using the script window. But we can start trying out our directly using the console window.\n\n\n\nAs R is an statistical program, of course it can do calculations. We can try that out by entering some basic calculations using the well-known mathematical operators.\n\n2+2\n\n[1] 4\n\n2^2\n\n[1] 4\n\n\n\n\n\nIf we want to enter multiple commands in one line, Either in the console or in the script window, we can separate them by using a semicolon. Each part divided by a; is treated like an individual command and is executed before the next in turn is then executed.\n\n(1 - 2) * 3; 1 - 2 * 3\n\n[1] -3\n\n\n[1] -5\n\n\n\n\n\nBeside the basic calculations R also offer us the possibility to do more complex calculations. Here we start using functions in R for the first time. Functions are commands that produce a certain output, most of the time requiring a certain input.The input usually is given by writing it in between the rounds brackets that distinguish a function call from a variable which we will see later. Functions can sometimes take more than one parameter these are then divided by, within the round brackets.\nIn the following example in the first line of “we calculate the square root, In the second example the natural logarithm of 10. If we would like to calculate the living room to the base of 10, we have to specify that using a second parameter.\n\nsqrt(2) #square root\n\n[1] 1.414214\n\nlog(10) #logarith base e\n\n[1] 2.302585\n\nlog(10, 10) #logarith base 10, like log(10, base=10)\n\n[1] 1\n\n\n\n\n\n\nThere is a specific function for getting help. Not surprisingly this function is called help. It takes as a parameter the name of the function for which you would like to get some information.\nCall of the help function:\n\nhelp(sqrt)\n\nLike it even simpler? You can also use the ‘?’ For getting help instead of writing the function name ‘help’. The name of the function for which you would like to have help it’s written after that ‘?’ .\n\n? sqrt\n\nYou can also search within the help files of R. Research capabilities are a limited only a fulltext search is conducted and you will not get any semantic relevant results. This means that if you would like to search for a specific topic, you probably already should know basically what you are searching for. More complicated searches probably better take place in the Internet. There are plenty of sites where you could get help or explanation how certain analyses are conducted.\nSearching the help:\n\nhelp.search('logarithm')\n\n\n\n\nA very essential concept in R is the concept of a variable. Variable can be seen as a kind of labelled drawer or replacement for an actual value that can be changed. It can become quite handy if for example you are writing a script or analyses, In which certain values might be changed in individual runs. Here you can define a replacement for the actual value that is the variable and specify the content of the variable for example in the beginning of the analyses. Here it can easily be changed if necessary.\nSetting the value of a variable is also called assignment. If we assign a value to a variable are is not reporting any message back. If we want to see the content of the variable we have to enter this variable itself without any other additions.\nThere are some data shipped with our. We will talk about datasets later. Some inbuilt constants are the letters of the alphabet, the names of the month and also the value of pi.\n\nx &lt;- 2 # no message will be given back\n\nx\n\n[1] 2\n\n\nThere are some data shipped with our. We will talk about datasets later. Some inbuilt constants are the letters of the alphabet, the names of the month and also the value of pi.\n\npi # build in variable\n\n[1] 3.141593\n\n\nWhen selecting variable names you’re quite free to choose. It is necessary, that the name of the variable starts with the letter. You should avoid using mathematical signs, because they could be interpreted as actual calculation. This means, you should not use the minus sign, but you’re perfectly free to use the underscore “_” or the dot “.”.\n\n\nThere are different options for the assignment sign in our. The traditional one is the arrow composed of a ‘smaller than’ sign and minus sign. Most other programming languages and now also our takes the = as an assignment. What you would like to use as a matter of taste. Personally I’d like the Aero more because it is more speaking and more clear.\nClassic assignment symbol in R is the arrow. Also possible:\n\nx=2\n\nBoth are possible.\n\n\n\n\nAnd this is helpful to get an overview about which variables we have already Defined. For this in our studio in the right hand area there is the environment window. If we want to get an overview about the assigned variables in our itself, we can use the command ls(). Currently there is only one variable in our environment. That is the variable X that we just assigned.\nDisplay of already uses variables:\n\nls()\n\n[1] \"x\"\n\n\nSometimes it might be helpful to get rid of one of the variables. To do this you can use the rm() command. This stands for remove. The name of the variable that has to be deleted is given within the round brackets ending the function call. If we after the removal of a variable get a listing of the variable environment again the variable should have gone.\nDelete a variable:\n\nrm(x) # no message will be given back\nls()\n\ncharacter(0)\n\n\n\n\n\n\nAlready have been said a variable can be used instead of an actual value. To do this we simply replace the use of the value with the name of the variable. For example if we want to use a variable when we calculate 2×2 we can at first assign 2 to one Variable and use it instead of actually writing to in our calculation. An important concept is also that the result of the calculation can also be assigned to a variable. With this we can chain analyses together and use the output of one of the functions as the input of the next function. In our example we assign to to the variable x, then we double its value and assign the results to the variable y. The result of this calculation is then used to calculate the square roots using the function sqrt().\nCalculations with variables:\n\nx &lt;- 2\ny &lt;- 2 * x\nz &lt;- sqrt(y) # no message will be given back\n\nNo using the function ls(), We can’t get an overview over our current environment. We should see now the 3 variable that we have created. Additionally if we inspect the individual variables, we shall see that y contains the value of four while z contains the value of two.\n\nls()\n\n[1] \"x\" \"y\" \"z\"\n\ny\n\n[1] 4\n\nz\n\n[1] 2\n\n\n\nGiven is a circle with the radius r=5. Calculate the diameter d (2 \\* r), the circumference u (2 \\* π \\* r) and the area a (π \\* r^2).\n\nAdd area a and circumference u, assign the result to the variable v and delete u and a.\n\n\n\nSolution\n\n\nr &lt;- 5\nd &lt;- 2 * r\nu &lt;- 2 * pi * r\na &lt;- pi * r^2\nv &lt;- a + u\nrm(u)\nrm(a)\n\n\n\n\n\n\nThere are four main data types in R: Scalars, vectors, matrices, data frames.\n\n\nScalar are individual values. This can be numbers text strings or true/false values. The essential characteristic is that it is only one value that is represented by a scalar.\nExamples of Scalar are all those variables that we used until now.\n\npi\n\n[1] 3.141593\n\n\nAll these variables stored only one value at the time.\n\n\n\nA vector is a variable that holds multiple values at the time in a one-dimensional data structure. You can’t imagine it as a kind of list where every item off the list again is a scalar.\nWe have already seen an example of a vector: the result of the listing of the variables, resulting from the command ls() represents a vector, where every position in this vector holds a scalar information, that is the name of the variable.\n\nls()\n\n[1] \"d\" \"r\" \"v\" \"x\" \"y\" \"z\"\n\n\n\n\n\nA vector is a one-dimensional data structure. If we add more dimensions to this idea, we end up with a Matrix. In the simplest implementation you can imagine a matrix as a table with rows and columns. That we have rows and columns represents the two-dimensionality of this data structure. Matrices with more dimensions are easily implementable, although our imagination probably will stop with three dimensions. Most of the time we will use two-dimensional matrices.\nAs with vectors, each element in a matrix represents a scalar value. One of the specific features of the data type matrix in R is, that all values have to be of the same kind. That means with in one and the same metrics, there can only be numbers, characters, or true and false values at once. We can’t mix these types of information in a matrix, which is the difference from the next data structure that we will learn.\nThere are also inbuilt matrices in R, for example are matrix holding the transfer rates between different European currencies. Of course these are restoring values and not updated online all the time\n\neuro.cross\n\n             ATS         BEF         DEM         ESP         FIM         FRF\nATS  1.000000000  2.93161486 0.142135709  12.0917422 0.432093050 0.476702543\nBEF  0.341108927  1.00000000 0.048483759   4.1246012 0.147390797 0.162607493\nDEM  7.035529673 20.62546336 1.000000000  85.0718109 3.040003477 3.353854885\nESP  0.082701069  0.24244768 0.011754775   1.0000000 0.035734557 0.039423810\nFIM  2.314316324  6.78468413 0.328946992  27.9841163 1.000000000 1.103240477\nFRF  2.097744212  6.14977811 0.298164361  25.3653822 0.906420695 1.000000000\nIEP 17.471976881 51.22110711 2.483391826 211.2666399 7.549519785 8.328935807\nITL  0.007106602  0.02083382 0.001010102   0.0859312 0.003070713 0.003387735\nLUF  0.341108927  1.00000000 0.048483759   4.1246012 0.147390797 0.162607493\nNLG  6.244151907 18.30544854 0.887516960  75.5026750 2.698054644 2.976603092\nPTE  0.068636087  0.20121457 0.009755639   0.8299299 0.029657176 0.032718997\n             IEP         ITL         LUF         NLG         PTE\nATS 0.0572345080  140.714229  2.93161486 0.160149851  14.5695951\nBEF 0.0195232016   47.998880  1.00000000 0.054628544   4.9698190\nDEM 0.4026750791  989.999131 20.62546336 1.126739032 102.5048189\nESP 0.0047333550   11.637217  0.24244768 0.013244564   1.2049211\nFIM 0.1324587561  325.657236  6.78468413 0.370637415  33.7186519\nFRF 0.1200633578  295.182459  6.14977811 0.335953424  30.5632839\nIEP 1.0000000000 2458.555749 51.22110711 2.798134501 254.5596294\nITL 0.0004067429    1.000000  0.02083382 0.001138121   0.1035403\nLUF 0.0195232016   47.998880  1.00000000 0.054628544   4.9698190\nNLG 0.3573809621  878.641019 18.30544854 1.000000000  90.9747653\nPTE 0.0039283527    9.658074  0.20121457 0.010992059   1.0000000\n\n\nYou can see that we have rows and columns here and both the rows and columns have names. In this example row and column names are the same because we have a special kind of matrix. But in general the names of the rows and columns can differ from each other. Matrices are specific data types with which you can conduct matrix algebra, which is a specific branch of mathematics that is also used in statistics. We will not deal with this very much. That’s why we most of the time will probably work more with the next data type.\n\n\n\nThe fourth of our data types is the data type data.frame. Similar to the matrix, this datatype represents a more than one dimensional data storage unit. Different from the matrix, in data frames values of different kinds can be stored. More specifically the different columns of the data frame can differ in respect of the contains data type. That means we can combine columns that have character values with columns that hold numeric values.\nTables in data frames are usually structured in a specific way: the rules usually hold the item off on investigation or the observations, while the columns usually holds the different features or variables of interest.\nOne example of such a data frame that is inbuilt in our is the data frame mtcars. This data frame contains the technical details of different cars. Also this is more a historical dataset.\n\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nYou can see, that the real names contains the names of the different cars, identifying them. The column names contains different measurements or information is, there are specific for the individual cars. The individual values identified by row and column then holds to specific values that are unique for this individual item or car.\nData frames are the data type that we will use most of the time, especially if we import data from other sources. How we can do that, will be shown subsequently. But at first we have to make sure, that we get our data from the right location on our computer. For that we need to concept of the working directory.\n\n\n\n\nHistorically, R is a software that has always been run within the console. Therefore it expects all its inputs from a specific folder on your computer, the working directory. Also, if any output is written to the disk on your computer, this also will take place in the specified working directory.\nOf course this working directory is not fixed, but you can specify that according to your specific workflow. At first we can use the command getwd() to see where on the computer I will working direct with currently is located.\n\ngetwd()\n\nThen we can use the command setwd(\"your/working/directory\") to set this working directory to a specific folder of your computer.\n\nsetwd(\"U:\\R\") # or something else\n\nHow specific folder has to be addressed, depends on the operating system. While Linux and macOS computers treat directory name is more or less the same, in Windows computers the path is prepared by the volume letter. With RStudio, there are different other options how are you can use the graphical user interface to specify the working directory. This might be more convenient than typing the path, especially if you are not used to it. You will find options for this in the files window of our studio, under the icon ‘More’, or in the main menu under the item ‘session’. Change the path according to your needs. Also you can make it a habit to check in the beginning of every R session, what do you work in directory is and if it is correctly specified.\n\n\n\nIn the reminder of the chapter we will need some files that can be downloaded using the following links:\n\nheight.RData\nkursmatrix.txt\nkursdata.txt\nkursdata.csv\n\nPlease save these files to the directory that you have defined as your working directory. In the following the used example will assume that the files are accessible directly, as they should be if they are placed in the working directory.\nRemember:\n\ngetwd()\nsetwd(\"my/location/of/my/working/directory\")\n\n\n\n\n\n\nData can be imported into R from different formats and sources. The most straightforward version is to directly scan a text file and read it into an R variable. For directly reading in a file we can use the function scan(). The file kursmatrix.txt is a simple text file in which ages and bodies sizes of individuals are listed consecutively. Scan reads in each item and translate it to a position in a vector.\n\nscan(\"kursmatrix.txt\")\n\n [1]  39  34  23  38  23  21  23  31  25  31  24  23  23  39  21 181 170 185 163\n[20] 175 163 162 172 172 180 187 158 184 156 168\n\n\nIf we, for example, want to turn this factor into a two-dimensional structure, like a matrix, we can use the command matrix to define such a structure and then use as an input the scanned content of the file. For the command matrix(), One of its parameters is the content that should be turned into a matrix, the second parameter is the number of columns that this matrix should have in end.\n\nkursmatrix &lt;- matrix(scan(\"kursmatrix.txt\"),ncol=2)\n\nThe result is a two-dimensional structure, with two columns, in which body height and age are listed in different columns.\n\nkursmatrix\n\n      [,1] [,2]\n [1,]   39  181\n [2,]   34  170\n [3,]   23  185\n [4,]   38  163\n [5,]   23  175\n [6,]   21  163\n [7,]   23  162\n [8,]   31  172\n [9,]   25  172\n[10,]   31  180\n[11,]   24  187\n[12,]   23  158\n[13,]   23  184\n[14,]   39  156\n[15,]   21  168\n\n\nThe file kursdata.txt contains a more complicated data structure. Here we have information is of different kinds, for example strings, but also numeric values. This kind of data can be imported into an data frame. The most general function to import table data is the function read.table().\n\nkursdata &lt;- read.table(\"kursdata.txt\")\n\nOne of the most widely used text file for exchange of numerical and other data are those in the CSV format. This format comes into flavours, Differentiated by the character that separates the columns. The original CSV format has a column separator “,” and a decimal separator using “.”. In European and other countries the “,” it’s often used as decimal separator. Therefore also a CSV2 format exists. Here the column separator is a “;”, while the decimal separator is, “. In Switzerland most of the time we will probably use the CSV2 format. In this format we have the same data available like we have in the kursdata.txt, the file is now called kursdata.csv.\n\nkursdata &lt;- read.csv2(\"kursdata.csv\")\nkursdata\n\n          X age height sex\n1  Matthias  39    181   m\n2   Jannick  34    170   m\n3   Nicolas  23    185   m\n4    Silvia  38    163   f\n5      Till  23    175   m\n6      Anna  21    163   f\n7    Ilaria  23    162   f\n8     Sarah  31    172   f\n9     Clara  25    172   f\n10    Alain  31    180   m\n11   Adrian  24    187   m\n12   Marlen  23    158   f\n13  Michael  23    184   m\n14   Helena  39    156   f\n15  Nephele  21    168   f\n\n\nIf we read in the data like this, you will realise, that there is a numeric naming, that is automatically given by R. If the dataset already consists of a unique identifier, that is a value, that is not repeated within the whole dataset, and that uniquely identify every individual item of the dataset, this can be used instead of the numeric identifier. This unifier of individual items is called row names in R. So if we specify in the read.CSV2 command, that we want to use for example the first column as row names, we can do it like this.\n\nkursdaten &lt;- read.csv2(\"kursdata.csv\",row.names = 1)\nkursdaten\n\n         age height sex\nMatthias  39    181   m\nJannick   34    170   m\nNicolas   23    185   m\nSilvia    38    163   f\nTill      23    175   m\nAnna      21    163   f\nIlaria    23    162   f\nSarah     31    172   f\nClara     25    172   f\nAlain     31    180   m\nAdrian    24    187   m\nMarlen    23    158   f\nMichael   23    184   m\nHelena    39    156   f\nNephele   21    168   f\n\n\n\n\n\n\nNow we know how we can assign more complicated data sets two variables by loading them from the file system. Sometimes, it might also be necessary, to directly assign more than one value to a variable. Let’s start with the example of a vector. A vector is created in R using the command c(). This ‘c’ stands for combine, and enables us to combine multiple values to be assigned to a variable, but also for different purposes.\nLet’s assume that we would like to make a vector of different Bronze Age sites. We assign the result to a variable called places.\n\nplaces &lt;- c(\"Leubingen\", \"Melz\", \"Bruszczewo\")\n\nAs in every other situation, in R actual value can be replaced with a variable. Also when we combine values we can not only combine actual values, in this case strings, but we also could use variables and combined them with other variables. To demonstrate that let’s make another vector of side categories that we call categories.\n\ncategories &lt;- c(\"burial\", \"depot\", \"settlement\")\ncategories\n\n[1] \"burial\"     \"depot\"      \"settlement\"\n\n\nNow we can combine these two factors into one.\n\nc(places, categories)\n\n[1] \"Leubingen\"  \"Melz\"       \"Bruszczewo\" \"burial\"     \"depot\"     \n[6] \"settlement\"\n\n\n\n\n\nWe already learnt to concept of row names and column names. Also places in a vector can have a specific identifier, the name. Since vectors do not have rows and columns, this feature is called only called ‘name’. We can use another vector to assign names, or we could directly enter names for the individual positions. In this case we use our category vector as base vector and the sites in the places vector as identifiers.\n\nnames(categories) &lt;- places\ncategories\n\n   Leubingen         Melz   Bruszczewo \n    \"burial\"      \"depot\" \"settlement\" \n\n\nThe result is a vector, in which every position has the name of the site is unique identifier, and where the values are the site categories for this specific archaeological sites.\n\n\n\n\nAlso variables with more complex content can, of course, be used in calculations and other functions. Due to their nature, and the fact that they contain more than one value, this of course changes the range of functions that can be applied to them. I will demonstrate that with a reduced version of our data. We will use only a vector of the body height of the individuals.\nFor this we explore a way of loading data into R. This time we use the need to data storage option of R. This format is called ‘RData’, and different from other loading or saving, we do not have to specify a variable name. In this case the variable is stored with its content, and if we load this dataset again, the variable is restored with the same name.\n\nload(\"height.RData\")\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     181      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\n\nNow we can use this vector that is assigned to the variable name height, to demonstrate some functions that make calculations over all the values that are stored in this vector. The first step probably comes to mind, is to sum up all the values. This can be done in R own using the function sum().\n\n# Sum:\nsum(height)\n\n[1] 2576\n\n\nWe can also count the number of values in the vector. The command for this is length().\n\n# Count:\nlength(height)\n\n[1] 15\n\n\nIf we have the number of cases, and to some of their individual values, we easily can calculate the arithmetic mean.\n\n# Mean:\nsum(height)/length(height)\n\n[1] 171.7333\n\n\nSince this is a very essential statistical value or parameter, of course there exists a specific command for this in R. There is no big surprise that this function is called mean().\n\n# Or more convenient:\nmean(height)\n\n[1] 171.7333\n\n\nOther possible functions might for example be related to the order and the extremes of the values within our dataset. We can sort the dataset according to the values, using the function sort(). In case of numerical values, the items will be sorted according to the numerical order. In case of characters, the items will be sorted according to the character. Our height data on numerical, therefore we will get them sorted from the smallest to the largest person.\n\n# sort:\nsort(height)\n\n  Helena   Marlen   Ilaria   Silvia     Anna  Nephele  Jannick    Sarah \n     156      158      162      163      163      168      170      172 \n   Clara     Till    Alain Matthias  Michael  Nicolas   Adrian \n     172      175      180      181      184      185      187 \n\n\nImmediately we can identify the smallest and the largest person. But we can also explicitly get the values using the function min() for minimum, and max() for maximum. The function range() gives both values at the same time.\n\n# minimum:\nmin(height)\n\n[1] 156\n\n# maximum:\nmax(height)\n\n[1] 187\n\n# Or both at the same time:\nrange(height)\n\n[1] 156 187\n\n\n\n\n\n\nNot only can we use functions on more complex variables like vectors, we also can do calculations. If, for example, we combine a scalar value With a mathematical expression with a vector, the calculation is done at every position of this vector. For example, if we want our height vector in metre, we have to divided by 100. We can directly apply this calculation to the whole variable, and the results will change every individual position in that vector. That means, we divide the variable by 100, and all the items in the variable are then divided by 100, causing every value to be in meter instead of centimeter.\n\nheight.in.m &lt;- height/100\nheight.in.m\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    1.81     1.70     1.85     1.63     1.75     1.63     1.62     1.72 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n    1.72     1.80     1.87     1.58     1.84     1.56     1.68 \n\n\nThe case is different if we combine to vectors with a mathematical expression. In this case, the first value of the first vector is combined with the first value of the second vector.The second value of the first vector is then combined with the second value of the second vector, and so forth.\n\ntest&lt;-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)\nheight.in.m + test\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    2.81     3.70     4.85     5.63     6.75     7.63     8.62     9.72 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n   10.72    11.80    12.87    13.58    14.84    15.56    16.68 \n\n\nIn case, that we have different number of positions in the individual factors vectors, the short one is “recycled”. That means, it starts again from the beginning. You can try that out yourself, if you take the example above and remove some items from the test vector.\n\nAn excavation produced the following numbers of flint artefacts:\n\n| flakes | blades | cores | debris |\n| ------ | ------ | ----- | ------ | \n| 506    | 104    | 30    | 267    |\n  \nAssign the values to a named vector, calculate the proportion of the artefacts and sort the vector according to their percentage\n\nDuring the data collection on box with artefacts was missing, the following numbers has to be added to the vector:\n\n| flakes | blades | cores | debris |\n| ------ | ------ | ----- | ------ | \n| 52     | 24     | 15    | 83     |\n\nMoreover were 10 items each artefact type missing. Make a vector for the box, add it and the 10 missing to the original data and repeat the calculations.\n\n\n\nSolution\n\n\nartefacts &lt;- c(506, 104, 30, 267)\nnames(artefacts) &lt;- c(\"flakes\", \"blades\", \"cores\", \"debris\")\n\nprop &lt;- artefacts/sum(artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.03307607 0.11466373 0.29437707 0.55788313 \n\nmissing_box &lt;- c(52,24,15,83)\nall_artefacts &lt;- artefacts + missing_box + 10\n\nprop &lt;- all_artefacts/sum(all_artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.04906334 0.12310437 0.32114184 0.50669045 \n\n\nVariant:\nWe also could have over written the content of the artefact variable with the new values including the missing box and the 10 additional items. In that case the court would look like this:\n\nartefacts &lt;- artefacts + missing_box + 10\n\nprop &lt;- artefacts/sum(artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.04906334 0.12310437 0.32114184 0.50669045 \n\n\nYou see, that artefact is twice present in the first line. This is possible, because the right-hand side of the assignment is evaluated first, and then the result is assigned to the actual variable.\nThis technique can also be used in actual scripts if you don’t need the intermediate values of the variable. It can become quite handy, to reduce the amount of variables and doing names. But you always will have to take care: you lose the intermediate values! So if you have to repeat any step in between, or later you would need some of the intermediate values you will not have them.\n\n\n\n\nNow we have seen, how we can produce vectors ourselves, and how we can use them in calculations. There are some specific vectors, either consisting of the repetition of an individual value, or sequences of values. There are some inbuilt functions in R that can help you producing these kinds of vectors fast.\nLet’s start with a simple sequence. Let’s assume, that we need the values from 1 to 10. We can produce such a simple sequence rather easily like this:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nBut also more complicated sequences are possible. For this we need an explicit function call for the function seq(). This command takes several parametres, the first one is the starting value, the second one the end value. You can also define the increment using the parameter by, or the desired length of the resulting vector, using the power meter length.\n\nseq(1,10,by=2)\n\n[1] 1 3 5 7 9\n\nseq(1,20,length=5)\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\nYou can check out other options and use cases indeed help documentation for this command.\nThe other mentioned option, the repetition, works for letters as well as for numeric values. The command here is rep(). Here, the first parameter is the value that should be repeated. This value can also be a vector. The second para meter is the number of times, that this value should be repeated. Also hear further options can be found in the documentation of the command.\n\nrep(1,10)\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrep(1:3,3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\nrep(c(\"Anton\",\"Berta\",\"Claudius\"),3)\n\n[1] \"Anton\"    \"Berta\"    \"Claudius\" \"Anton\"    \"Berta\"    \"Claudius\" \"Anton\"   \n[8] \"Berta\"    \"Claudius\"\n\n\n\n\n\n\n\nAnd important possibility is to access data with in such a complex structure like for example a vector. By convention, for accessing data in R, square brackets are used. Indicates of a one-dimensional data structure, within the brackets you can give the position of the item that you would like to access. This can be an individual number, a vector of numbers, Or, by using the minus sign, you can also exclude eighter individual value or a range of values. Here, sequences can become very handy.\n\nheight[1]\n\nMatthias \n     181 \n\nheight[5]\n\nTill \n 175 \n\nheight[1:3]\n\nMatthias  Jannick  Nicolas \n     181      170      185 \n\nheight[-(1:3)]\n\n Silvia    Till    Anna  Ilaria   Sarah   Clara   Alain  Adrian  Marlen Michael \n    163     175     163     162     172     172     180     187     158     184 \n Helena Nephele \n    156     168 \n\n\nIf we have a named vector, like for example with our heigth data, these positions have also and unique identifier. In that case, we can also use the unique identifier, to access a specific position in our data storage vector.\n\nheight[\"Clara\"]\n\nClara \n  172 \n\n\nThis data access is two ways: not only can we get the values at a specific position, but we can also change the values, given that we indicate a specific position in the vector. In the following example at first the content of the vector height is shown, then we change the entry in the first value, and you can inspect the effect.\n\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     181      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\nheight[1] &lt;- 168\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     168      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\n\nOf course the same is true for the access by name.\n\nheight[\"Till\"] &lt;- 181\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     168      170      185      163      181      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\n\n\n\n\n\nUntil now we had only vectors or other variables that stored either numeric values or strings. No we learn another category of data type: the logical values. These are also called binary, boolean, or true/false values. These values can result from inequations or checks:\n\npi&gt;4\n\n[1] FALSE\n\nheight &gt; 175\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n   FALSE    FALSE     TRUE    FALSE     TRUE    FALSE    FALSE    FALSE \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n   FALSE     TRUE     TRUE    FALSE     TRUE    FALSE    FALSE \n\n\nbut you can also enter them yourself. Logical values are entered as ‘TRUE’ or ‘FALSE’. But there is also a shortcut, ‘T’ or ‘F’ would be enough.\n\nlogic_test &lt;- c(T,F)\nlogic_test == T\n\n[1]  TRUE FALSE\n\nlogic_test == F\n\n[1] FALSE  TRUE\n\n\nAbove you can also see another specific way of how an equation sign is used in our in a comparison. In this situation, two ‘=’ are used to distinguish it from the assignment situation.\nComparisons, and the resulting logical values, can become very helpful when selecting specific values in a dataset. For example, if you want to select all the individuals that are larger than 1 m 75, you can do that by including a comparison in the square brackets used for accessing data. You can also use the command which() to identify in which cases a certain comparison would be true. Lastly, logical values are internally sorted as 0 and 1, and can therefore also be used in calculations or counts. For example, if we want to identify, how many percent of our individuals are larger than 1 m 75, we can sum the results from this comparison. In case that this comparison would return true, it would also return one. By summing up the ones, we get a count. Dividing the count by the number of cases, we get the percentage.\n\nheight[height&gt;175]\n\nNicolas    Till   Alain  Adrian Michael \n    185     181     180     187     184 \n\nwhich(height&gt;175)\n\nNicolas    Till   Alain  Adrian Michael \n      3       5      10      11      13 \n\nsum(height&gt;175)/length(height)\n\n[1] 0.3333333\n\n\n\n\n\nThe last type of information are factors. A factor is a codified textual information that is within a very specific range of values. An example for a factor might be the sex of an individual. From the biological determination, this can result in male, female, or undetermined. This means we have only three values. The difference between a factor variable and character variable is, that internally the values are stored as numbers. The table translates then the number to the actual textual representation.\n\nsex &lt;- factor(c(\"m\", \"m\", \"m\", \"f\", \"m\", \"f\", \"f\",\n                \"f\", \"f\", \"m\", \"m\", \"f\", \"m\", \"f\", \"f\"))\nsex\n\n [1] m m m f m f f f f m m f m f f\nLevels: f m\n\n\nAnother specific feature of factor variables is that they can also represent ordered values. We might see this later.\n\n\n\n\nMissing values are annoying in every kind of investigation. They have to be treated in a specific way, distinguishing them from the situation where the value is zero. If we have a value that is zero, this means we have information that the value is actually zero.\nIn our example you can see the effect. If we set the height of an individual person to 0, and then calculate the mean, we get the wrong result.\n\nheight[\"Marlen\"] &lt;- 0\n\nmean(height)\n\n[1] 160.7333\n\nsum(height)/14\n\n[1] 172.2143\n\n\nSo this can cause problems, if we would use the 0 as an encoding for missing information. For this purpose there is a specific value called ‘not available’ or NA. If we set the value of an individual item to not available NA, and then calculate the mean, the result is NA. This is a warning sign, that in the dataset there are missing cases. We can use the parameter na.rm=T, read NA remove it’s true, to ignore all the NAs and to conduct the calculation of the mean value. This is true for a lot of other functions.\n\nheight[\"Marlen\"] &lt;- NA\n\nmean(height)\n\n[1] NA\n\nmean(height, na.rm=T)\n\n[1] 172.2143\n\n\n\n\n\nWe initially have already talked about the matrices, Two or more dimentional data storage, which also can be used in mathematical procedures. This of course is only true, if the matrix contains numerical values only. And, as we have already seen, do matrices also have names. Since we talk about more dimensional objects, we have to be specific, about which names we talk. That is because in the case of matrices, but also in the case of data frames, we talk about row names and column names.\nWe already have loaded the information about people in the form of the kursmatrix.\n\nkursmatrix\n\n      [,1] [,2]\n [1,]   39  181\n [2,]   34  170\n [3,]   23  185\n [4,]   38  163\n [5,]   23  175\n [6,]   21  163\n [7,]   23  162\n [8,]   31  172\n [9,]   25  172\n[10,]   31  180\n[11,]   24  187\n[12,]   23  158\n[13,]   23  184\n[14,]   39  156\n[15,]   21  168\n\n\nThis is already in the conventional representation: the rows contain information about a specific item, the columns contain each specific variable. To make this more clear, we should assign row and column names. Also here, like with the names for vectors, we can use either variables or actual values.\n\nrownames(kursmatrix) &lt;- names(height)\ncolnames(kursmatrix)&lt;-c(\"age\", \"height\")\nkursmatrix\n\n         age height\nMatthias  39    181\nJannick   34    170\nNicolas   23    185\nSilvia    38    163\nTill      23    175\nAnna      21    163\nIlaria    23    162\nSarah     31    172\nClara     25    172\nAlain     31    180\nAdrian    24    187\nMarlen    23    158\nMichael   23    184\nHelena    39    156\nNephele   21    168\n\n\nLike with vectors, mathematical operations are possible with matrices. Actually that is a their prime purpose. For example, we can divide a metrics by 100 or any other scalar value. The result will be a matrix, in which every individual value is divided by this scalar, in the specific case 100.\n\nkursmatrix / 100\n\n          age height\nMatthias 0.39   1.81\nJannick  0.34   1.70\nNicolas  0.23   1.85\nSilvia   0.38   1.63\nTill     0.23   1.75\nAnna     0.21   1.63\nIlaria   0.23   1.62\nSarah    0.31   1.72\nClara    0.25   1.72\nAlain    0.31   1.80\nAdrian   0.24   1.87\nMarlen   0.23   1.58\nMichael  0.23   1.84\nHelena   0.39   1.56\nNephele  0.21   1.68\n\n\nWe can also access individual values within a matrix. This is done in the same way like with vectors. So either, using the position in the form of a number, or by name. Since now we have a more dimensional data object, we also have more dimensions to specify, if we would like to access a specific value. In the case of a two-dimensional matrix, for example, we have to give two positions to identify a specific value. These positions are separated by a comma. General, rows are the first dimension, while columns are the second dimension in our. So rows first, Callums second is a rule, that is applicable for a lot of other situations.\nIf we specify only one of the positions, we refer to either the whole column, or the whole row. The result is then again a vector. Also on this selection, like on every other vector, we can apply mathematical operations.\n\nkursmatrix[, 1] / 100\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    0.39     0.34     0.23     0.38     0.23     0.21     0.23     0.31 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n    0.25     0.31     0.24     0.23     0.23     0.39     0.21 \n\n\nAlso in this case, if we combine a matrix with a vector, the same logic is to like if we combine to vectors. So if we combine a mattress and a vector, Every value of the vector is combined with every value of the Matrixx starting with the first vector within the matrix. If we combine a matrix and the matrix, then the first value in the first column of the first matrix is combined with the first value of the first column in the second matrix, and so on, equivalent to the way in which vectors are combined.\n\nkursmatrix / c(1:15, rep(2, 15))\n\n               age height\nMatthias 39.000000   90.5\nJannick  17.000000   85.0\nNicolas   7.666667   92.5\nSilvia    9.500000   81.5\nTill      4.600000   87.5\nAnna      3.500000   81.5\nIlaria    3.285714   81.0\nSarah     3.875000   86.0\nClara     2.777778   86.0\nAlain     3.100000   90.0\nAdrian    2.181818   93.5\nMarlen    1.916667   79.0\nMichael   1.769231   92.0\nHelena    2.785714   78.0\nNephele   1.400000   84.0\n\n\nTo get a feeling for these rules, it is best that you try out different combinations, and observe the results.\n\n\n\nThe last of the major data types, that we have already seen, is the data frame. A data frame results either from the import of a CSV file, or it can be created on the spot in R by combining different vectors in a more dimensional table. These factors also can come from a matrix. For this we used to command data.frame(), which constructs a data frame. The columns are their names are given in this construction, and their values are assigned with an = after this. You aware, that we do not assign actually in this example a variable age with the values of the matrix, but only a column within the data frame. That is one of the reasons, why the syntax using the assignment arrow is more clear, because it differentiate from this construction of the data frame.\n\nkursdata &lt;- \n  data.frame(age = kursmatrix[,1],\n             height = kursmatrix[,2],\n             sex=sex)\nkursdata\n\n         age height sex\nMatthias  39    181   m\nJannick   34    170   m\nNicolas   23    185   m\nSilvia    38    163   f\nTill      23    175   m\nAnna      21    163   f\nIlaria    23    162   f\nSarah     31    172   f\nClara     25    172   f\nAlain     31    180   m\nAdrian    24    187   m\nMarlen    23    158   f\nMichael   23    184   m\nHelena    39    156   f\nNephele   21    168   f\n\n\nAlso in the case of a data frame, very similar to the situation with the matrix, we can access individuals rows or columns by either index or name. In case of the data frame there is specific notation for accessing the content of a specific column: for this we can use the $.\n\nkursdata[,\"age\"]\n\n [1] 39 34 23 38 23 21 23 31 25 31 24 23 23 39 21\n\nkursdata$age\n\n [1] 39 34 23 38 23 21 23 31 25 31 24 23 23 39 21\n\n\nLike with matrices, we can use data frames in calculations. Since in a DataFrame also non-numerical values can be stored, this is not always make sense. But we can use the notation above to specify individual columns and assign calculations to them.\nAdditionally a very useful command can be the command summary(). This gives you a summary of the individual columns of data frame, but can also be used with other objects in R. The way in which the summary is conducted might depend on the specific object.\n\nkursdata$height / 100\n\n [1] 1.81 1.70 1.85 1.63 1.75 1.63 1.62 1.72 1.72 1.80 1.87 1.58 1.84 1.56 1.68\n\nsummary(kursdata)\n\n      age            height      sex  \n Min.   :21.00   Min.   :156.0   f:8  \n 1st Qu.:23.00   1st Qu.:163.0   m:7  \n Median :24.00   Median :172.0        \n Mean   :27.87   Mean   :171.7        \n 3rd Qu.:32.50   3rd Qu.:180.5        \n Max.   :39.00   Max.   :187.0        \n\ntapply(kursdata$height, kursdata$sex, mean, na.rm=T)\n\n       f        m \n164.2500 180.2857 \n\n\nThe last line in this piece of code above is an example, how are you can use this $notation very handy in function calls. This example applies to the vector height in the dataset the calculation of the mean, differentiated by the sex, and also ignores potentially NA values. This kind of notation is very close to what you probably will use later on a lot in your actual analyses.\nThere are several datasets inbuilt in R that can be used for experimentation or testing out certain functionalities. You can get a list of this using the command data(). The resulting list might be very long, its length depends on the number of packages that you have installed. The list below only serves as an example. You have to try it out yourself, if you want to have the full list.\n\ndata()\n\n\nData sets in package 'datasets':\n\nAirPassengers           Monthly Airline Passenger Numbers 1949-1960\nBJsales                 Sales Data with Leading Indicator\nBJsales.lead (BJsales)\n                        Sales Data with Leading Indicator\nBOD                     Biochemical Oxygen Demand\nCO2                     Carbon Dioxide Uptake in Grass Plants\nChickWeight             Weight versus age of chicks on different diets\nDNase                   Elisa assay of DNase\nEuStockMarkets          Daily Closing Prices of Major European Stock\n                        Indices, 1991-1998\nFormaldehyde            Determination of Formaldehyde\nHairEyeColor            Hair and Eye Color of Statistics Students\nHarman23.cor            Harman Example 2.3\n\n\n\n\nFinally, if we finished our analyses, most of the time we also need to export some data. This is an analogy to the options to read data into our. The most basic option would be to directly write a simple text file. With this option you lose a lot of the internal structure of the dataset, and it is not for certain, that it will be imported in the right way.\n\nwrite(kursmatrix,\"kursmatrix.txt\")\n\nSpecially, if you have a data frame, it makes more sense to write it directly as a table. With the command wright.table() you can specify a lot of options how the dataset will be stored. If you’d like to know, please consult do you documentation.\n\nwrite.table(kursdata,\"kursdata.txt\")\n\nBut most of the time, you will probably not need all the flexibility, that ride table gives you. Most of the time, you will like to write a CSV file, because this is the standard exchange file between R and a lot of other software, including spreadsheet software like Microsoft Excel.\n\nwrite.csv2(kursdata,\"kursdata.csv\")\n\nAs we have said earlier, please pay attention to the language setting off your computer. Most of the time, at least in Switzerland, you will have a European continental setting, where the decimal separator is a comma. In that case, it is likely that you would like to use the CSV2 format. To try out the differences, you can run the cockpit below, and open the resulting file in your spreadsheet software. You can also inspect it with a text editor.\n\nkursdata$height &lt;- kursdata$height/100\nwrite.csv(kursdata,\"kursdata.csv\")\n\nYou very likely will have problems with Microsoft Excel. Over spreadsheet software might be smarter. Nevertheless, if you are on the continent, you would like to save your data in the way like below.\n\nwrite.csv2(kursdata,\"kursdata.csv\")\n\nOf course, R also offer us packages, that directly can save files in .XLSX format. The downside of these packages are, that most of the time they require additional dependencies or programming languages, for example perl or python. And actually using the CSV format this is not necessary at all. So it is best that you develop the habit to use CSV as you exchange format between different software.\nWith this, now I hope, that we have everything at hand, so that we can start using R as actual software. In the next chapter we will start producing that part of statistics, that most people think of when statistics are mentioned: graphs, diagrams, and tables."
  },
  {
    "objectID": "02_session/02-chapter.html#start-r-studio",
    "href": "02_session/02-chapter.html#start-r-studio",
    "title": "Introduction into R",
    "section": "",
    "text": "When we first start R Studio, we see a screen divided into several windows. On the left-hand side, directly after the start, we are greeted by the large R window, the Console. This is where the actual R programme is located. On the right, there are windows that provide further helpful functions. In the upper area we have the window in which we can see the working environment. On the one hand, there is the actual environment, marked by the tab ‘Environment’. Next to this, perhaps of interest to us at the moment, is the ‘History’ tab, in which we can see the sequence of commands entered so far. The file manager is located in the lower right-hand corner. Other tabs contain information about diagrams (plots), packages and a window in which we can use the R help system.\nOne important window is still missing: the code or script window. This only appears when we open a new R file. To do this, either click on the plus symbol at the top left or select ‘File -&gt; New File’ from the menu. This opens another window which is placed in the top left by default and in which you enter your programme code for the analyses. This window functions as a normal text editor window, i.e. if you press Enter here, the text is not directly executed, but a new line is created. To actually execute a command, you can either click on the Run symbol in the upper area or use the keyboard shortcut Control Enter."
  },
  {
    "objectID": "02_session/02-chapter.html#using-r",
    "href": "02_session/02-chapter.html#using-r",
    "title": "Introduction into R",
    "section": "",
    "text": "After R is started, you end on the prompt.\n&gt;\nThis prompt expects your commands. It can be used to directly enter commands or conduct calculations like with a normal calculator. We mainly will not use R in this way.Most of the real work is done using the script window. But we can start trying out our directly using the console window.\n\n\n\nAs R is an statistical program, of course it can do calculations. We can try that out by entering some basic calculations using the well-known mathematical operators.\n\n2+2\n\n[1] 4\n\n2^2\n\n[1] 4\n\n\n\n\n\nIf we want to enter multiple commands in one line, Either in the console or in the script window, we can separate them by using a semicolon. Each part divided by a; is treated like an individual command and is executed before the next in turn is then executed.\n\n(1 - 2) * 3; 1 - 2 * 3\n\n[1] -3\n\n\n[1] -5\n\n\n\n\n\nBeside the basic calculations R also offer us the possibility to do more complex calculations. Here we start using functions in R for the first time. Functions are commands that produce a certain output, most of the time requiring a certain input.The input usually is given by writing it in between the rounds brackets that distinguish a function call from a variable which we will see later. Functions can sometimes take more than one parameter these are then divided by, within the round brackets.\nIn the following example in the first line of “we calculate the square root, In the second example the natural logarithm of 10. If we would like to calculate the living room to the base of 10, we have to specify that using a second parameter.\n\nsqrt(2) #square root\n\n[1] 1.414214\n\nlog(10) #logarith base e\n\n[1] 2.302585\n\nlog(10, 10) #logarith base 10, like log(10, base=10)\n\n[1] 1"
  },
  {
    "objectID": "02_session/02-chapter.html#getting-help",
    "href": "02_session/02-chapter.html#getting-help",
    "title": "Introduction into R",
    "section": "",
    "text": "There is a specific function for getting help. Not surprisingly this function is called help. It takes as a parameter the name of the function for which you would like to get some information.\nCall of the help function:\n\nhelp(sqrt)\n\nLike it even simpler? You can also use the ‘?’ For getting help instead of writing the function name ‘help’. The name of the function for which you would like to have help it’s written after that ‘?’ .\n\n? sqrt\n\nYou can also search within the help files of R. Research capabilities are a limited only a fulltext search is conducted and you will not get any semantic relevant results. This means that if you would like to search for a specific topic, you probably already should know basically what you are searching for. More complicated searches probably better take place in the Internet. There are plenty of sites where you could get help or explanation how certain analyses are conducted.\nSearching the help:\n\nhelp.search('logarithm')"
  },
  {
    "objectID": "02_session/02-chapter.html#assignment-of-data-to-variables",
    "href": "02_session/02-chapter.html#assignment-of-data-to-variables",
    "title": "Introduction into R",
    "section": "",
    "text": "A very essential concept in R is the concept of a variable. Variable can be seen as a kind of labelled drawer or replacement for an actual value that can be changed. It can become quite handy if for example you are writing a script or analyses, In which certain values might be changed in individual runs. Here you can define a replacement for the actual value that is the variable and specify the content of the variable for example in the beginning of the analyses. Here it can easily be changed if necessary.\nSetting the value of a variable is also called assignment. If we assign a value to a variable are is not reporting any message back. If we want to see the content of the variable we have to enter this variable itself without any other additions.\nThere are some data shipped with our. We will talk about datasets later. Some inbuilt constants are the letters of the alphabet, the names of the month and also the value of pi.\n\nx &lt;- 2 # no message will be given back\n\nx\n\n[1] 2\n\n\nThere are some data shipped with our. We will talk about datasets later. Some inbuilt constants are the letters of the alphabet, the names of the month and also the value of pi.\n\npi # build in variable\n\n[1] 3.141593\n\n\nWhen selecting variable names you’re quite free to choose. It is necessary, that the name of the variable starts with the letter. You should avoid using mathematical signs, because they could be interpreted as actual calculation. This means, you should not use the minus sign, but you’re perfectly free to use the underscore “_” or the dot “.”.\n\n\nThere are different options for the assignment sign in our. The traditional one is the arrow composed of a ‘smaller than’ sign and minus sign. Most other programming languages and now also our takes the = as an assignment. What you would like to use as a matter of taste. Personally I’d like the Aero more because it is more speaking and more clear.\nClassic assignment symbol in R is the arrow. Also possible:\n\nx=2\n\nBoth are possible."
  },
  {
    "objectID": "02_session/02-chapter.html#working-with-variables",
    "href": "02_session/02-chapter.html#working-with-variables",
    "title": "Introduction into R",
    "section": "",
    "text": "And this is helpful to get an overview about which variables we have already Defined. For this in our studio in the right hand area there is the environment window. If we want to get an overview about the assigned variables in our itself, we can use the command ls(). Currently there is only one variable in our environment. That is the variable X that we just assigned.\nDisplay of already uses variables:\n\nls()\n\n[1] \"x\"\n\n\nSometimes it might be helpful to get rid of one of the variables. To do this you can use the rm() command. This stands for remove. The name of the variable that has to be deleted is given within the round brackets ending the function call. If we after the removal of a variable get a listing of the variable environment again the variable should have gone.\nDelete a variable:\n\nrm(x) # no message will be given back\nls()\n\ncharacter(0)"
  },
  {
    "objectID": "02_session/02-chapter.html#using-variables",
    "href": "02_session/02-chapter.html#using-variables",
    "title": "Introduction into R",
    "section": "",
    "text": "Already have been said a variable can be used instead of an actual value. To do this we simply replace the use of the value with the name of the variable. For example if we want to use a variable when we calculate 2×2 we can at first assign 2 to one Variable and use it instead of actually writing to in our calculation. An important concept is also that the result of the calculation can also be assigned to a variable. With this we can chain analyses together and use the output of one of the functions as the input of the next function. In our example we assign to to the variable x, then we double its value and assign the results to the variable y. The result of this calculation is then used to calculate the square roots using the function sqrt().\nCalculations with variables:\n\nx &lt;- 2\ny &lt;- 2 * x\nz &lt;- sqrt(y) # no message will be given back\n\nNo using the function ls(), We can’t get an overview over our current environment. We should see now the 3 variable that we have created. Additionally if we inspect the individual variables, we shall see that y contains the value of four while z contains the value of two.\n\nls()\n\n[1] \"x\" \"y\" \"z\"\n\ny\n\n[1] 4\n\nz\n\n[1] 2\n\n\n\nGiven is a circle with the radius r=5. Calculate the diameter d (2 \\* r), the circumference u (2 \\* π \\* r) and the area a (π \\* r^2).\n\nAdd area a and circumference u, assign the result to the variable v and delete u and a.\n\n\n\nSolution\n\n\nr &lt;- 5\nd &lt;- 2 * r\nu &lt;- 2 * pi * r\na &lt;- pi * r^2\nv &lt;- a + u\nrm(u)\nrm(a)"
  },
  {
    "objectID": "02_session/02-chapter.html#data-types-in-r-variables",
    "href": "02_session/02-chapter.html#data-types-in-r-variables",
    "title": "Introduction into R",
    "section": "",
    "text": "There are four main data types in R: Scalars, vectors, matrices, data frames.\n\n\nScalar are individual values. This can be numbers text strings or true/false values. The essential characteristic is that it is only one value that is represented by a scalar.\nExamples of Scalar are all those variables that we used until now.\n\npi\n\n[1] 3.141593\n\n\nAll these variables stored only one value at the time.\n\n\n\nA vector is a variable that holds multiple values at the time in a one-dimensional data structure. You can’t imagine it as a kind of list where every item off the list again is a scalar.\nWe have already seen an example of a vector: the result of the listing of the variables, resulting from the command ls() represents a vector, where every position in this vector holds a scalar information, that is the name of the variable.\n\nls()\n\n[1] \"d\" \"r\" \"v\" \"x\" \"y\" \"z\"\n\n\n\n\n\nA vector is a one-dimensional data structure. If we add more dimensions to this idea, we end up with a Matrix. In the simplest implementation you can imagine a matrix as a table with rows and columns. That we have rows and columns represents the two-dimensionality of this data structure. Matrices with more dimensions are easily implementable, although our imagination probably will stop with three dimensions. Most of the time we will use two-dimensional matrices.\nAs with vectors, each element in a matrix represents a scalar value. One of the specific features of the data type matrix in R is, that all values have to be of the same kind. That means with in one and the same metrics, there can only be numbers, characters, or true and false values at once. We can’t mix these types of information in a matrix, which is the difference from the next data structure that we will learn.\nThere are also inbuilt matrices in R, for example are matrix holding the transfer rates between different European currencies. Of course these are restoring values and not updated online all the time\n\neuro.cross\n\n             ATS         BEF         DEM         ESP         FIM         FRF\nATS  1.000000000  2.93161486 0.142135709  12.0917422 0.432093050 0.476702543\nBEF  0.341108927  1.00000000 0.048483759   4.1246012 0.147390797 0.162607493\nDEM  7.035529673 20.62546336 1.000000000  85.0718109 3.040003477 3.353854885\nESP  0.082701069  0.24244768 0.011754775   1.0000000 0.035734557 0.039423810\nFIM  2.314316324  6.78468413 0.328946992  27.9841163 1.000000000 1.103240477\nFRF  2.097744212  6.14977811 0.298164361  25.3653822 0.906420695 1.000000000\nIEP 17.471976881 51.22110711 2.483391826 211.2666399 7.549519785 8.328935807\nITL  0.007106602  0.02083382 0.001010102   0.0859312 0.003070713 0.003387735\nLUF  0.341108927  1.00000000 0.048483759   4.1246012 0.147390797 0.162607493\nNLG  6.244151907 18.30544854 0.887516960  75.5026750 2.698054644 2.976603092\nPTE  0.068636087  0.20121457 0.009755639   0.8299299 0.029657176 0.032718997\n             IEP         ITL         LUF         NLG         PTE\nATS 0.0572345080  140.714229  2.93161486 0.160149851  14.5695951\nBEF 0.0195232016   47.998880  1.00000000 0.054628544   4.9698190\nDEM 0.4026750791  989.999131 20.62546336 1.126739032 102.5048189\nESP 0.0047333550   11.637217  0.24244768 0.013244564   1.2049211\nFIM 0.1324587561  325.657236  6.78468413 0.370637415  33.7186519\nFRF 0.1200633578  295.182459  6.14977811 0.335953424  30.5632839\nIEP 1.0000000000 2458.555749 51.22110711 2.798134501 254.5596294\nITL 0.0004067429    1.000000  0.02083382 0.001138121   0.1035403\nLUF 0.0195232016   47.998880  1.00000000 0.054628544   4.9698190\nNLG 0.3573809621  878.641019 18.30544854 1.000000000  90.9747653\nPTE 0.0039283527    9.658074  0.20121457 0.010992059   1.0000000\n\n\nYou can see that we have rows and columns here and both the rows and columns have names. In this example row and column names are the same because we have a special kind of matrix. But in general the names of the rows and columns can differ from each other. Matrices are specific data types with which you can conduct matrix algebra, which is a specific branch of mathematics that is also used in statistics. We will not deal with this very much. That’s why we most of the time will probably work more with the next data type.\n\n\n\nThe fourth of our data types is the data type data.frame. Similar to the matrix, this datatype represents a more than one dimensional data storage unit. Different from the matrix, in data frames values of different kinds can be stored. More specifically the different columns of the data frame can differ in respect of the contains data type. That means we can combine columns that have character values with columns that hold numeric values.\nTables in data frames are usually structured in a specific way: the rules usually hold the item off on investigation or the observations, while the columns usually holds the different features or variables of interest.\nOne example of such a data frame that is inbuilt in our is the data frame mtcars. This data frame contains the technical details of different cars. Also this is more a historical dataset.\n\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nYou can see, that the real names contains the names of the different cars, identifying them. The column names contains different measurements or information is, there are specific for the individual cars. The individual values identified by row and column then holds to specific values that are unique for this individual item or car.\nData frames are the data type that we will use most of the time, especially if we import data from other sources. How we can do that, will be shown subsequently. But at first we have to make sure, that we get our data from the right location on our computer. For that we need to concept of the working directory.\n\n\n\n\nHistorically, R is a software that has always been run within the console. Therefore it expects all its inputs from a specific folder on your computer, the working directory. Also, if any output is written to the disk on your computer, this also will take place in the specified working directory.\nOf course this working directory is not fixed, but you can specify that according to your specific workflow. At first we can use the command getwd() to see where on the computer I will working direct with currently is located.\n\ngetwd()\n\nThen we can use the command setwd(\"your/working/directory\") to set this working directory to a specific folder of your computer.\n\nsetwd(\"U:\\R\") # or something else\n\nHow specific folder has to be addressed, depends on the operating system. While Linux and macOS computers treat directory name is more or less the same, in Windows computers the path is prepared by the volume letter. With RStudio, there are different other options how are you can use the graphical user interface to specify the working directory. This might be more convenient than typing the path, especially if you are not used to it. You will find options for this in the files window of our studio, under the icon ‘More’, or in the main menu under the item ‘session’. Change the path according to your needs. Also you can make it a habit to check in the beginning of every R session, what do you work in directory is and if it is correctly specified.\n\n\n\nIn the reminder of the chapter we will need some files that can be downloaded using the following links:\n\nheight.RData\nkursmatrix.txt\nkursdata.txt\nkursdata.csv\n\nPlease save these files to the directory that you have defined as your working directory. In the following the used example will assume that the files are accessible directly, as they should be if they are placed in the working directory.\nRemember:\n\ngetwd()\nsetwd(\"my/location/of/my/working/directory\")"
  },
  {
    "objectID": "02_session/02-chapter.html#data-import-through-reading-of-files",
    "href": "02_session/02-chapter.html#data-import-through-reading-of-files",
    "title": "Introduction into R",
    "section": "",
    "text": "Data can be imported into R from different formats and sources. The most straightforward version is to directly scan a text file and read it into an R variable. For directly reading in a file we can use the function scan(). The file kursmatrix.txt is a simple text file in which ages and bodies sizes of individuals are listed consecutively. Scan reads in each item and translate it to a position in a vector.\n\nscan(\"kursmatrix.txt\")\n\n [1]  39  34  23  38  23  21  23  31  25  31  24  23  23  39  21 181 170 185 163\n[20] 175 163 162 172 172 180 187 158 184 156 168\n\n\nIf we, for example, want to turn this factor into a two-dimensional structure, like a matrix, we can use the command matrix to define such a structure and then use as an input the scanned content of the file. For the command matrix(), One of its parameters is the content that should be turned into a matrix, the second parameter is the number of columns that this matrix should have in end.\n\nkursmatrix &lt;- matrix(scan(\"kursmatrix.txt\"),ncol=2)\n\nThe result is a two-dimensional structure, with two columns, in which body height and age are listed in different columns.\n\nkursmatrix\n\n      [,1] [,2]\n [1,]   39  181\n [2,]   34  170\n [3,]   23  185\n [4,]   38  163\n [5,]   23  175\n [6,]   21  163\n [7,]   23  162\n [8,]   31  172\n [9,]   25  172\n[10,]   31  180\n[11,]   24  187\n[12,]   23  158\n[13,]   23  184\n[14,]   39  156\n[15,]   21  168\n\n\nThe file kursdata.txt contains a more complicated data structure. Here we have information is of different kinds, for example strings, but also numeric values. This kind of data can be imported into an data frame. The most general function to import table data is the function read.table().\n\nkursdata &lt;- read.table(\"kursdata.txt\")\n\nOne of the most widely used text file for exchange of numerical and other data are those in the CSV format. This format comes into flavours, Differentiated by the character that separates the columns. The original CSV format has a column separator “,” and a decimal separator using “.”. In European and other countries the “,” it’s often used as decimal separator. Therefore also a CSV2 format exists. Here the column separator is a “;”, while the decimal separator is, “. In Switzerland most of the time we will probably use the CSV2 format. In this format we have the same data available like we have in the kursdata.txt, the file is now called kursdata.csv.\n\nkursdata &lt;- read.csv2(\"kursdata.csv\")\nkursdata\n\n          X age height sex\n1  Matthias  39    181   m\n2   Jannick  34    170   m\n3   Nicolas  23    185   m\n4    Silvia  38    163   f\n5      Till  23    175   m\n6      Anna  21    163   f\n7    Ilaria  23    162   f\n8     Sarah  31    172   f\n9     Clara  25    172   f\n10    Alain  31    180   m\n11   Adrian  24    187   m\n12   Marlen  23    158   f\n13  Michael  23    184   m\n14   Helena  39    156   f\n15  Nephele  21    168   f\n\n\nIf we read in the data like this, you will realise, that there is a numeric naming, that is automatically given by R. If the dataset already consists of a unique identifier, that is a value, that is not repeated within the whole dataset, and that uniquely identify every individual item of the dataset, this can be used instead of the numeric identifier. This unifier of individual items is called row names in R. So if we specify in the read.CSV2 command, that we want to use for example the first column as row names, we can do it like this.\n\nkursdaten &lt;- read.csv2(\"kursdata.csv\",row.names = 1)\nkursdaten\n\n         age height sex\nMatthias  39    181   m\nJannick   34    170   m\nNicolas   23    185   m\nSilvia    38    163   f\nTill      23    175   m\nAnna      21    163   f\nIlaria    23    162   f\nSarah     31    172   f\nClara     25    172   f\nAlain     31    180   m\nAdrian    24    187   m\nMarlen    23    158   f\nMichael   23    184   m\nHelena    39    156   f\nNephele   21    168   f"
  },
  {
    "objectID": "02_session/02-chapter.html#using-c-for-data-entry",
    "href": "02_session/02-chapter.html#using-c-for-data-entry",
    "title": "Introduction into R",
    "section": "",
    "text": "Now we know how we can assign more complicated data sets two variables by loading them from the file system. Sometimes, it might also be necessary, to directly assign more than one value to a variable. Let’s start with the example of a vector. A vector is created in R using the command c(). This ‘c’ stands for combine, and enables us to combine multiple values to be assigned to a variable, but also for different purposes.\nLet’s assume that we would like to make a vector of different Bronze Age sites. We assign the result to a variable called places.\n\nplaces &lt;- c(\"Leubingen\", \"Melz\", \"Bruszczewo\")\n\nAs in every other situation, in R actual value can be replaced with a variable. Also when we combine values we can not only combine actual values, in this case strings, but we also could use variables and combined them with other variables. To demonstrate that let’s make another vector of side categories that we call categories.\n\ncategories &lt;- c(\"burial\", \"depot\", \"settlement\")\ncategories\n\n[1] \"burial\"     \"depot\"      \"settlement\"\n\n\nNow we can combine these two factors into one.\n\nc(places, categories)\n\n[1] \"Leubingen\"  \"Melz\"       \"Bruszczewo\" \"burial\"     \"depot\"     \n[6] \"settlement\""
  },
  {
    "objectID": "02_session/02-chapter.html#named-vectors",
    "href": "02_session/02-chapter.html#named-vectors",
    "title": "Introduction into R",
    "section": "",
    "text": "We already learnt to concept of row names and column names. Also places in a vector can have a specific identifier, the name. Since vectors do not have rows and columns, this feature is called only called ‘name’. We can use another vector to assign names, or we could directly enter names for the individual positions. In this case we use our category vector as base vector and the sites in the places vector as identifiers.\n\nnames(categories) &lt;- places\ncategories\n\n   Leubingen         Melz   Bruszczewo \n    \"burial\"      \"depot\" \"settlement\" \n\n\nThe result is a vector, in which every position has the name of the site is unique identifier, and where the values are the site categories for this specific archaeological sites."
  },
  {
    "objectID": "02_session/02-chapter.html#applying-functions-to-more-complex-variables",
    "href": "02_session/02-chapter.html#applying-functions-to-more-complex-variables",
    "title": "Introduction into R",
    "section": "",
    "text": "Also variables with more complex content can, of course, be used in calculations and other functions. Due to their nature, and the fact that they contain more than one value, this of course changes the range of functions that can be applied to them. I will demonstrate that with a reduced version of our data. We will use only a vector of the body height of the individuals.\nFor this we explore a way of loading data into R. This time we use the need to data storage option of R. This format is called ‘RData’, and different from other loading or saving, we do not have to specify a variable name. In this case the variable is stored with its content, and if we load this dataset again, the variable is restored with the same name.\n\nload(\"height.RData\")\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     181      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\n\nNow we can use this vector that is assigned to the variable name height, to demonstrate some functions that make calculations over all the values that are stored in this vector. The first step probably comes to mind, is to sum up all the values. This can be done in R own using the function sum().\n\n# Sum:\nsum(height)\n\n[1] 2576\n\n\nWe can also count the number of values in the vector. The command for this is length().\n\n# Count:\nlength(height)\n\n[1] 15\n\n\nIf we have the number of cases, and to some of their individual values, we easily can calculate the arithmetic mean.\n\n# Mean:\nsum(height)/length(height)\n\n[1] 171.7333\n\n\nSince this is a very essential statistical value or parameter, of course there exists a specific command for this in R. There is no big surprise that this function is called mean().\n\n# Or more convenient:\nmean(height)\n\n[1] 171.7333\n\n\nOther possible functions might for example be related to the order and the extremes of the values within our dataset. We can sort the dataset according to the values, using the function sort(). In case of numerical values, the items will be sorted according to the numerical order. In case of characters, the items will be sorted according to the character. Our height data on numerical, therefore we will get them sorted from the smallest to the largest person.\n\n# sort:\nsort(height)\n\n  Helena   Marlen   Ilaria   Silvia     Anna  Nephele  Jannick    Sarah \n     156      158      162      163      163      168      170      172 \n   Clara     Till    Alain Matthias  Michael  Nicolas   Adrian \n     172      175      180      181      184      185      187 \n\n\nImmediately we can identify the smallest and the largest person. But we can also explicitly get the values using the function min() for minimum, and max() for maximum. The function range() gives both values at the same time.\n\n# minimum:\nmin(height)\n\n[1] 156\n\n# maximum:\nmax(height)\n\n[1] 187\n\n# Or both at the same time:\nrange(height)\n\n[1] 156 187"
  },
  {
    "objectID": "02_session/02-chapter.html#calculations-with-vectors",
    "href": "02_session/02-chapter.html#calculations-with-vectors",
    "title": "Introduction into R",
    "section": "",
    "text": "Not only can we use functions on more complex variables like vectors, we also can do calculations. If, for example, we combine a scalar value With a mathematical expression with a vector, the calculation is done at every position of this vector. For example, if we want our height vector in metre, we have to divided by 100. We can directly apply this calculation to the whole variable, and the results will change every individual position in that vector. That means, we divide the variable by 100, and all the items in the variable are then divided by 100, causing every value to be in meter instead of centimeter.\n\nheight.in.m &lt;- height/100\nheight.in.m\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    1.81     1.70     1.85     1.63     1.75     1.63     1.62     1.72 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n    1.72     1.80     1.87     1.58     1.84     1.56     1.68 \n\n\nThe case is different if we combine to vectors with a mathematical expression. In this case, the first value of the first vector is combined with the first value of the second vector.The second value of the first vector is then combined with the second value of the second vector, and so forth.\n\ntest&lt;-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)\nheight.in.m + test\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    2.81     3.70     4.85     5.63     6.75     7.63     8.62     9.72 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n   10.72    11.80    12.87    13.58    14.84    15.56    16.68 \n\n\nIn case, that we have different number of positions in the individual factors vectors, the short one is “recycled”. That means, it starts again from the beginning. You can try that out yourself, if you take the example above and remove some items from the test vector.\n\nAn excavation produced the following numbers of flint artefacts:\n\n| flakes | blades | cores | debris |\n| ------ | ------ | ----- | ------ | \n| 506    | 104    | 30    | 267    |\n  \nAssign the values to a named vector, calculate the proportion of the artefacts and sort the vector according to their percentage\n\nDuring the data collection on box with artefacts was missing, the following numbers has to be added to the vector:\n\n| flakes | blades | cores | debris |\n| ------ | ------ | ----- | ------ | \n| 52     | 24     | 15    | 83     |\n\nMoreover were 10 items each artefact type missing. Make a vector for the box, add it and the 10 missing to the original data and repeat the calculations.\n\n\n\nSolution\n\n\nartefacts &lt;- c(506, 104, 30, 267)\nnames(artefacts) &lt;- c(\"flakes\", \"blades\", \"cores\", \"debris\")\n\nprop &lt;- artefacts/sum(artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.03307607 0.11466373 0.29437707 0.55788313 \n\nmissing_box &lt;- c(52,24,15,83)\nall_artefacts &lt;- artefacts + missing_box + 10\n\nprop &lt;- all_artefacts/sum(all_artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.04906334 0.12310437 0.32114184 0.50669045 \n\n\nVariant:\nWe also could have over written the content of the artefact variable with the new values including the missing box and the 10 additional items. In that case the court would look like this:\n\nartefacts &lt;- artefacts + missing_box + 10\n\nprop &lt;- artefacts/sum(artefacts)\nsort(prop)\n\n     cores     blades     debris     flakes \n0.04906334 0.12310437 0.32114184 0.50669045 \n\n\nYou see, that artefact is twice present in the first line. This is possible, because the right-hand side of the assignment is evaluated first, and then the result is assigned to the actual variable.\nThis technique can also be used in actual scripts if you don’t need the intermediate values of the variable. It can become quite handy, to reduce the amount of variables and doing names. But you always will have to take care: you lose the intermediate values! So if you have to repeat any step in between, or later you would need some of the intermediate values you will not have them."
  },
  {
    "objectID": "02_session/02-chapter.html#sequences-and-repeated-data",
    "href": "02_session/02-chapter.html#sequences-and-repeated-data",
    "title": "Introduction into R",
    "section": "",
    "text": "Now we have seen, how we can produce vectors ourselves, and how we can use them in calculations. There are some specific vectors, either consisting of the repetition of an individual value, or sequences of values. There are some inbuilt functions in R that can help you producing these kinds of vectors fast.\nLet’s start with a simple sequence. Let’s assume, that we need the values from 1 to 10. We can produce such a simple sequence rather easily like this:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nBut also more complicated sequences are possible. For this we need an explicit function call for the function seq(). This command takes several parametres, the first one is the starting value, the second one the end value. You can also define the increment using the parameter by, or the desired length of the resulting vector, using the power meter length.\n\nseq(1,10,by=2)\n\n[1] 1 3 5 7 9\n\nseq(1,20,length=5)\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\nYou can check out other options and use cases indeed help documentation for this command.\nThe other mentioned option, the repetition, works for letters as well as for numeric values. The command here is rep(). Here, the first parameter is the value that should be repeated. This value can also be a vector. The second para meter is the number of times, that this value should be repeated. Also hear further options can be found in the documentation of the command.\n\nrep(1,10)\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrep(1:3,3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\nrep(c(\"Anton\",\"Berta\",\"Claudius\"),3)\n\n[1] \"Anton\"    \"Berta\"    \"Claudius\" \"Anton\"    \"Berta\"    \"Claudius\" \"Anton\"   \n[8] \"Berta\"    \"Claudius\""
  },
  {
    "objectID": "02_session/02-chapter.html#data-access",
    "href": "02_session/02-chapter.html#data-access",
    "title": "Introduction into R",
    "section": "",
    "text": "And important possibility is to access data with in such a complex structure like for example a vector. By convention, for accessing data in R, square brackets are used. Indicates of a one-dimensional data structure, within the brackets you can give the position of the item that you would like to access. This can be an individual number, a vector of numbers, Or, by using the minus sign, you can also exclude eighter individual value or a range of values. Here, sequences can become very handy.\n\nheight[1]\n\nMatthias \n     181 \n\nheight[5]\n\nTill \n 175 \n\nheight[1:3]\n\nMatthias  Jannick  Nicolas \n     181      170      185 \n\nheight[-(1:3)]\n\n Silvia    Till    Anna  Ilaria   Sarah   Clara   Alain  Adrian  Marlen Michael \n    163     175     163     162     172     172     180     187     158     184 \n Helena Nephele \n    156     168 \n\n\nIf we have a named vector, like for example with our heigth data, these positions have also and unique identifier. In that case, we can also use the unique identifier, to access a specific position in our data storage vector.\n\nheight[\"Clara\"]\n\nClara \n  172 \n\n\nThis data access is two ways: not only can we get the values at a specific position, but we can also change the values, given that we indicate a specific position in the vector. In the following example at first the content of the vector height is shown, then we change the entry in the first value, and you can inspect the effect.\n\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     181      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\nheight[1] &lt;- 168\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     168      170      185      163      175      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168 \n\n\nOf course the same is true for the access by name.\n\nheight[\"Till\"] &lt;- 181\nheight\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n     168      170      185      163      181      163      162      172 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n     172      180      187      158      184      156      168"
  },
  {
    "objectID": "02_session/02-chapter.html#logical-values",
    "href": "02_session/02-chapter.html#logical-values",
    "title": "Introduction into R",
    "section": "",
    "text": "Until now we had only vectors or other variables that stored either numeric values or strings. No we learn another category of data type: the logical values. These are also called binary, boolean, or true/false values. These values can result from inequations or checks:\n\npi&gt;4\n\n[1] FALSE\n\nheight &gt; 175\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n   FALSE    FALSE     TRUE    FALSE     TRUE    FALSE    FALSE    FALSE \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n   FALSE     TRUE     TRUE    FALSE     TRUE    FALSE    FALSE \n\n\nbut you can also enter them yourself. Logical values are entered as ‘TRUE’ or ‘FALSE’. But there is also a shortcut, ‘T’ or ‘F’ would be enough.\n\nlogic_test &lt;- c(T,F)\nlogic_test == T\n\n[1]  TRUE FALSE\n\nlogic_test == F\n\n[1] FALSE  TRUE\n\n\nAbove you can also see another specific way of how an equation sign is used in our in a comparison. In this situation, two ‘=’ are used to distinguish it from the assignment situation.\nComparisons, and the resulting logical values, can become very helpful when selecting specific values in a dataset. For example, if you want to select all the individuals that are larger than 1 m 75, you can do that by including a comparison in the square brackets used for accessing data. You can also use the command which() to identify in which cases a certain comparison would be true. Lastly, logical values are internally sorted as 0 and 1, and can therefore also be used in calculations or counts. For example, if we want to identify, how many percent of our individuals are larger than 1 m 75, we can sum the results from this comparison. In case that this comparison would return true, it would also return one. By summing up the ones, we get a count. Dividing the count by the number of cases, we get the percentage.\n\nheight[height&gt;175]\n\nNicolas    Till   Alain  Adrian Michael \n    185     181     180     187     184 \n\nwhich(height&gt;175)\n\nNicolas    Till   Alain  Adrian Michael \n      3       5      10      11      13 \n\nsum(height&gt;175)/length(height)\n\n[1] 0.3333333"
  },
  {
    "objectID": "02_session/02-chapter.html#factors",
    "href": "02_session/02-chapter.html#factors",
    "title": "Introduction into R",
    "section": "",
    "text": "The last type of information are factors. A factor is a codified textual information that is within a very specific range of values. An example for a factor might be the sex of an individual. From the biological determination, this can result in male, female, or undetermined. This means we have only three values. The difference between a factor variable and character variable is, that internally the values are stored as numbers. The table translates then the number to the actual textual representation.\n\nsex &lt;- factor(c(\"m\", \"m\", \"m\", \"f\", \"m\", \"f\", \"f\",\n                \"f\", \"f\", \"m\", \"m\", \"f\", \"m\", \"f\", \"f\"))\nsex\n\n [1] m m m f m f f f f m m f m f f\nLevels: f m\n\n\nAnother specific feature of factor variables is that they can also represent ordered values. We might see this later."
  },
  {
    "objectID": "02_session/02-chapter.html#missing-na-values",
    "href": "02_session/02-chapter.html#missing-na-values",
    "title": "Introduction into R",
    "section": "",
    "text": "Missing values are annoying in every kind of investigation. They have to be treated in a specific way, distinguishing them from the situation where the value is zero. If we have a value that is zero, this means we have information that the value is actually zero.\nIn our example you can see the effect. If we set the height of an individual person to 0, and then calculate the mean, we get the wrong result.\n\nheight[\"Marlen\"] &lt;- 0\n\nmean(height)\n\n[1] 160.7333\n\nsum(height)/14\n\n[1] 172.2143\n\n\nSo this can cause problems, if we would use the 0 as an encoding for missing information. For this purpose there is a specific value called ‘not available’ or NA. If we set the value of an individual item to not available NA, and then calculate the mean, the result is NA. This is a warning sign, that in the dataset there are missing cases. We can use the parameter na.rm=T, read NA remove it’s true, to ignore all the NAs and to conduct the calculation of the mean value. This is true for a lot of other functions.\n\nheight[\"Marlen\"] &lt;- NA\n\nmean(height)\n\n[1] NA\n\nmean(height, na.rm=T)\n\n[1] 172.2143"
  },
  {
    "objectID": "02_session/02-chapter.html#matrices",
    "href": "02_session/02-chapter.html#matrices",
    "title": "Introduction into R",
    "section": "",
    "text": "We initially have already talked about the matrices, Two or more dimentional data storage, which also can be used in mathematical procedures. This of course is only true, if the matrix contains numerical values only. And, as we have already seen, do matrices also have names. Since we talk about more dimensional objects, we have to be specific, about which names we talk. That is because in the case of matrices, but also in the case of data frames, we talk about row names and column names.\nWe already have loaded the information about people in the form of the kursmatrix.\n\nkursmatrix\n\n      [,1] [,2]\n [1,]   39  181\n [2,]   34  170\n [3,]   23  185\n [4,]   38  163\n [5,]   23  175\n [6,]   21  163\n [7,]   23  162\n [8,]   31  172\n [9,]   25  172\n[10,]   31  180\n[11,]   24  187\n[12,]   23  158\n[13,]   23  184\n[14,]   39  156\n[15,]   21  168\n\n\nThis is already in the conventional representation: the rows contain information about a specific item, the columns contain each specific variable. To make this more clear, we should assign row and column names. Also here, like with the names for vectors, we can use either variables or actual values.\n\nrownames(kursmatrix) &lt;- names(height)\ncolnames(kursmatrix)&lt;-c(\"age\", \"height\")\nkursmatrix\n\n         age height\nMatthias  39    181\nJannick   34    170\nNicolas   23    185\nSilvia    38    163\nTill      23    175\nAnna      21    163\nIlaria    23    162\nSarah     31    172\nClara     25    172\nAlain     31    180\nAdrian    24    187\nMarlen    23    158\nMichael   23    184\nHelena    39    156\nNephele   21    168\n\n\nLike with vectors, mathematical operations are possible with matrices. Actually that is a their prime purpose. For example, we can divide a metrics by 100 or any other scalar value. The result will be a matrix, in which every individual value is divided by this scalar, in the specific case 100.\n\nkursmatrix / 100\n\n          age height\nMatthias 0.39   1.81\nJannick  0.34   1.70\nNicolas  0.23   1.85\nSilvia   0.38   1.63\nTill     0.23   1.75\nAnna     0.21   1.63\nIlaria   0.23   1.62\nSarah    0.31   1.72\nClara    0.25   1.72\nAlain    0.31   1.80\nAdrian   0.24   1.87\nMarlen   0.23   1.58\nMichael  0.23   1.84\nHelena   0.39   1.56\nNephele  0.21   1.68\n\n\nWe can also access individual values within a matrix. This is done in the same way like with vectors. So either, using the position in the form of a number, or by name. Since now we have a more dimensional data object, we also have more dimensions to specify, if we would like to access a specific value. In the case of a two-dimensional matrix, for example, we have to give two positions to identify a specific value. These positions are separated by a comma. General, rows are the first dimension, while columns are the second dimension in our. So rows first, Callums second is a rule, that is applicable for a lot of other situations.\nIf we specify only one of the positions, we refer to either the whole column, or the whole row. The result is then again a vector. Also on this selection, like on every other vector, we can apply mathematical operations.\n\nkursmatrix[, 1] / 100\n\nMatthias  Jannick  Nicolas   Silvia     Till     Anna   Ilaria    Sarah \n    0.39     0.34     0.23     0.38     0.23     0.21     0.23     0.31 \n   Clara    Alain   Adrian   Marlen  Michael   Helena  Nephele \n    0.25     0.31     0.24     0.23     0.23     0.39     0.21 \n\n\nAlso in this case, if we combine a matrix with a vector, the same logic is to like if we combine to vectors. So if we combine a mattress and a vector, Every value of the vector is combined with every value of the Matrixx starting with the first vector within the matrix. If we combine a matrix and the matrix, then the first value in the first column of the first matrix is combined with the first value of the first column in the second matrix, and so on, equivalent to the way in which vectors are combined.\n\nkursmatrix / c(1:15, rep(2, 15))\n\n               age height\nMatthias 39.000000   90.5\nJannick  17.000000   85.0\nNicolas   7.666667   92.5\nSilvia    9.500000   81.5\nTill      4.600000   87.5\nAnna      3.500000   81.5\nIlaria    3.285714   81.0\nSarah     3.875000   86.0\nClara     2.777778   86.0\nAlain     3.100000   90.0\nAdrian    2.181818   93.5\nMarlen    1.916667   79.0\nMichael   1.769231   92.0\nHelena    2.785714   78.0\nNephele   1.400000   84.0\n\n\nTo get a feeling for these rules, it is best that you try out different combinations, and observe the results."
  },
  {
    "objectID": "02_session/02-chapter.html#data-frames",
    "href": "02_session/02-chapter.html#data-frames",
    "title": "Introduction into R",
    "section": "",
    "text": "The last of the major data types, that we have already seen, is the data frame. A data frame results either from the import of a CSV file, or it can be created on the spot in R by combining different vectors in a more dimensional table. These factors also can come from a matrix. For this we used to command data.frame(), which constructs a data frame. The columns are their names are given in this construction, and their values are assigned with an = after this. You aware, that we do not assign actually in this example a variable age with the values of the matrix, but only a column within the data frame. That is one of the reasons, why the syntax using the assignment arrow is more clear, because it differentiate from this construction of the data frame.\n\nkursdata &lt;- \n  data.frame(age = kursmatrix[,1],\n             height = kursmatrix[,2],\n             sex=sex)\nkursdata\n\n         age height sex\nMatthias  39    181   m\nJannick   34    170   m\nNicolas   23    185   m\nSilvia    38    163   f\nTill      23    175   m\nAnna      21    163   f\nIlaria    23    162   f\nSarah     31    172   f\nClara     25    172   f\nAlain     31    180   m\nAdrian    24    187   m\nMarlen    23    158   f\nMichael   23    184   m\nHelena    39    156   f\nNephele   21    168   f\n\n\nAlso in the case of a data frame, very similar to the situation with the matrix, we can access individuals rows or columns by either index or name. In case of the data frame there is specific notation for accessing the content of a specific column: for this we can use the $.\n\nkursdata[,\"age\"]\n\n [1] 39 34 23 38 23 21 23 31 25 31 24 23 23 39 21\n\nkursdata$age\n\n [1] 39 34 23 38 23 21 23 31 25 31 24 23 23 39 21\n\n\nLike with matrices, we can use data frames in calculations. Since in a DataFrame also non-numerical values can be stored, this is not always make sense. But we can use the notation above to specify individual columns and assign calculations to them.\nAdditionally a very useful command can be the command summary(). This gives you a summary of the individual columns of data frame, but can also be used with other objects in R. The way in which the summary is conducted might depend on the specific object.\n\nkursdata$height / 100\n\n [1] 1.81 1.70 1.85 1.63 1.75 1.63 1.62 1.72 1.72 1.80 1.87 1.58 1.84 1.56 1.68\n\nsummary(kursdata)\n\n      age            height      sex  \n Min.   :21.00   Min.   :156.0   f:8  \n 1st Qu.:23.00   1st Qu.:163.0   m:7  \n Median :24.00   Median :172.0        \n Mean   :27.87   Mean   :171.7        \n 3rd Qu.:32.50   3rd Qu.:180.5        \n Max.   :39.00   Max.   :187.0        \n\ntapply(kursdata$height, kursdata$sex, mean, na.rm=T)\n\n       f        m \n164.2500 180.2857 \n\n\nThe last line in this piece of code above is an example, how are you can use this $notation very handy in function calls. This example applies to the vector height in the dataset the calculation of the mean, differentiated by the sex, and also ignores potentially NA values. This kind of notation is very close to what you probably will use later on a lot in your actual analyses.\nThere are several datasets inbuilt in R that can be used for experimentation or testing out certain functionalities. You can get a list of this using the command data(). The resulting list might be very long, its length depends on the number of packages that you have installed. The list below only serves as an example. You have to try it out yourself, if you want to have the full list.\n\ndata()\n\n\nData sets in package 'datasets':\n\nAirPassengers           Monthly Airline Passenger Numbers 1949-1960\nBJsales                 Sales Data with Leading Indicator\nBJsales.lead (BJsales)\n                        Sales Data with Leading Indicator\nBOD                     Biochemical Oxygen Demand\nCO2                     Carbon Dioxide Uptake in Grass Plants\nChickWeight             Weight versus age of chicks on different diets\nDNase                   Elisa assay of DNase\nEuStockMarkets          Daily Closing Prices of Major European Stock\n                        Indices, 1991-1998\nFormaldehyde            Determination of Formaldehyde\nHairEyeColor            Hair and Eye Color of Statistics Students\nHarman23.cor            Harman Example 2.3"
  },
  {
    "objectID": "02_session/02-chapter.html#data-export-through-save",
    "href": "02_session/02-chapter.html#data-export-through-save",
    "title": "Introduction into R",
    "section": "",
    "text": "Finally, if we finished our analyses, most of the time we also need to export some data. This is an analogy to the options to read data into our. The most basic option would be to directly write a simple text file. With this option you lose a lot of the internal structure of the dataset, and it is not for certain, that it will be imported in the right way.\n\nwrite(kursmatrix,\"kursmatrix.txt\")\n\nSpecially, if you have a data frame, it makes more sense to write it directly as a table. With the command wright.table() you can specify a lot of options how the dataset will be stored. If you’d like to know, please consult do you documentation.\n\nwrite.table(kursdata,\"kursdata.txt\")\n\nBut most of the time, you will probably not need all the flexibility, that ride table gives you. Most of the time, you will like to write a CSV file, because this is the standard exchange file between R and a lot of other software, including spreadsheet software like Microsoft Excel.\n\nwrite.csv2(kursdata,\"kursdata.csv\")\n\nAs we have said earlier, please pay attention to the language setting off your computer. Most of the time, at least in Switzerland, you will have a European continental setting, where the decimal separator is a comma. In that case, it is likely that you would like to use the CSV2 format. To try out the differences, you can run the cockpit below, and open the resulting file in your spreadsheet software. You can also inspect it with a text editor.\n\nkursdata$height &lt;- kursdata$height/100\nwrite.csv(kursdata,\"kursdata.csv\")\n\nYou very likely will have problems with Microsoft Excel. Over spreadsheet software might be smarter. Nevertheless, if you are on the continent, you would like to save your data in the way like below.\n\nwrite.csv2(kursdata,\"kursdata.csv\")\n\nOf course, R also offer us packages, that directly can save files in .XLSX format. The downside of these packages are, that most of the time they require additional dependencies or programming languages, for example perl or python. And actually using the CSV format this is not necessary at all. So it is best that you develop the habit to use CSV as you exchange format between different software.\nWith this, now I hope, that we have everything at hand, so that we can start using R as actual software. In the next chapter we will start producing that part of statistics, that most people think of when statistics are mentioned: graphs, diagrams, and tables."
  },
  {
    "objectID": "book/index.html",
    "href": "book/index.html",
    "title": "Statistical Methods for Archaeological Data Analysis",
    "section": "",
    "text": "Preface\nHallo Welt!"
  },
  {
    "objectID": "book.html",
    "href": "book.html",
    "title": "Statistical Methods for Archaeological Data Analysis",
    "section": "",
    "text": "Preface\nHallo Welt!"
  }
]